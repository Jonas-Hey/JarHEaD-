== Access Control ==

{{PRODUCT}} manages access rights of users via ''Access Control Lists'' (ACLs). {{PRODUCT}} allows to configure roles freely. As a default, preconfigured ACLs for the roles ''guest'', ''user'', and ''admin'' are available. The following section describes the ACL concept, its syntax, and the specification of new ACLs in detail. Information on how to grant rights to individual users based on roles can be found in section [[Help:RoleMapping|Role Mapping]].

An ''Access Control List'' defines the access rights of a given user in a specific role. {{PRODUCT}} allows to control access at both resource and functional levels. Resource ACLs can be used to limit access to certain pages, e.g., by forbidding pages that use a certain namespace, or resources of a given RDF type. Functional ACLs restrict UI components such as widgets and buttons, as well as interfaces such as servlets and APIs methods.

A single user may have several ACLs associated, one for each of his roles. As an example, consider a user ''dummy'' and assume the user is associated to the roles ''admin'' and ''editor''. Then the user may have associated up to three ACLs: one ACL specifying the rights for the ''admin'' role, one for the ''editor'' role, and one specific ACL for the user ''dummy'' itself. By convention, an empty ACL grants no rights, so if there is no ACL defined explicitly for the user but there are ACLs defined for the two roles, then his rights are defined by means of the two role ACLs. When multiple ACLs are defined, {{PRODUCT}} applies a '''disjunctive''' semantics, i.e. in that case the user has the rights of the ''admin'' role plus the rights of the ''editor'' role. This means that, even if the access to some component is explicitly forbidden in some role, say e.g. editors are not allowed to access the admin area, but allowed in the other role, say ''admin'' members are allowed to visit the admin area, then the user is granted the right to visit the admin area.

=== Definitions ===

'''Identity Management'''
* an identity management (IDM) system allows defining users, groups and group memberships (m:n relationship)
* User: a user known to one of the IDMs attached to the {{PRODUCT}} login chain
* Group: a group known to one of the IDMs attached to the {{PRODUCT}} login chain
* consequently, {{PRODUCT}} users and groups are the union of users and groups defined in each attached IDM
* {{PRODUCT}} comes with a simple built-in IDM based on secrets.xml
* also see [[Help:UserManagement]]

'''Authentication'''
* {{PRODUCT}} allows defining a chain of IDM systems
* IDM authenticates users
* An {{PRODUCT}} login is successful if one of the IDM in the {{PRODUCT}} login chain successfully authenticates the user
* also see [[Help:Authentication]]

'''Access Control'''
* a user session has a set of access control statements attached
* Example: allow|widget|regexp(.*), defines that all widgets can be used
* Access for a certain feature is granted if one of the access control statements allows it
* also see the sections below for details

'''Roles'''
* users and groups can have multiple roles in the system
* a role consists of a set of access control statements defined in config/acl/role-...acl
* roles can include other roles: 
** @includeRole: ecm-base
** @includedByRole: wiki-edit

'''Groups vs. Roles'''
* Groups come from the IDM
* Roles come from {{PRODUCT}} and {{PRODUCT}} Apps
* There are groups that are also roles (e.g. eCloudManager Admins). This means that there is a file role-eCloudManager Admins.acl and there is a group eCloudManager Admins in the IDM
* There are IDM groups without a corresponding {{PRODUCT}} role (e.g. IIS_ADMINS)
* There are {{PRODUCT}} roles without a corresponding IDM group (e.g. ecm-base)

=== Attaching Roles to Users ===

This section describes how users get their roles assigned. For details, please refer to the section [[Help:RoleMapping]].

'''role mapping'''
* using the share dialog, groups can be mapped to roles globally (i.e. by selecting the resource “Everything”)
'''role = group'''
* user logs in and the IDM informs {{PRODUCT}} about the groups the user is in
* if there is a role with the same name as a user group, the user is in this roles and the included roles
'''sharing'''
* for a given resource, {{PRODUCT}} can be instructed to attach a role R to a user / group via the share / permissions dialog
* when viewing this resource, the user has the additional role R if the user or one of the user’s groups has R attached
'''context mapper'''
* sharing can be extended from a static resource to a dynamic set of resources using context mappers
* if a user is shared on resource X and a context mapper defines X to be its URI, the context mapper is invoked to calculate dynamic sharing
* example: Platform:Owner is associated to ''ResponsibleAsOwnerContextMapper'' which checks whether the current user has a :responsible relationship to the resource being viewed


=== High Level ACL Process ===

In order to determine whether a user can access a certain component, the following process is applied:

* user and static user groups (e.g. eCloudManager Operators) are stored in the UserContext upon login
* user visits page X
* user is in any role that 
** matches one of his groups or expanded roles (included via @includeRole)
** is shared for the user / one of his groups explicitly on X
** is shared for the user / one of his groups by an active context mapper the has X in its expanded set via dynamic roles
* add expanded roles to the user’s role set
* union all access control statements of all roles the user is in
* check the access control statements for a statement that allows or denies the component access (see description in the section below)



=== ACL Syntax ===
An ACL is a list of ''access control rules'' that allow or deny access to a specific entity. ACLs are evaluated in '''sequential order'''. The syntax of an access control rule is defined as follows in EBNF:

<source>
Rule = Permission, "|", RuleType, "|", Entity, ["|", AccessType], ["|", Priority] ;
</source>

Generally speaking, an access control rule consist of (up to) five fields, separated by the symbol "|". The first field contains either the keyword ''deny'' or ''allow'', specifying whether the rule denies or allows access, respectively. The second field is the type of the access control rule, specifying which kind of access right is denied or granted. The available rule types will be described in the next section. The third field identifies the entity that is referred to by the ACL. The fourth field contains the type of access that is granted (if the keyword in the first field is ''deny'', then the fourth field is empty). Finally, the fifth field contains the priority of the permission. This is given as a number, where higher numbers mean higher priority. If no priority is specified, zero is used as default.

As an example, consider the following ACL consisting of two rules:

<source>
deny|resource|regexp(http:\/\/www\.fluidops\.com\/admin\/.*)
allow|resource|regexp(.*)|read
</source>

Both rules are of type resource, i.e., they specify whether the user has access to a page. The first rule uses a regular expression to forbid access to all pages in the Admin area. The second rule grants access to all other pages. The access type ''read'' means that the user is allowed to see the content of the pages, but he is not allowed to author wiki pages or data. Given that the rules are evaluated sequentially, the combination of both rules gives the user access to all pages except for those residing in the admin area.

Note that, implicitly, {{PRODUCT}} inserts a denying rule at the end of each ACL for everything that has not been specified. For the example above, where no write access has been granted to the user, this means that the user indeed has only read access to all pages. As a consequence, an empty ACL does not grant any access at all.

The remaining section discusses the individual types of access control rules and describes how these rules are interpreted by the system.

=== Resource-level AC Rules ===
A resource-level AC Rule is a string of the form

<source>
ResourceRule = "deny", "|", ResourceType, "|", Entity, ["|", Priority]
            | "allow", "|", ResourceType, "|", Entity, "|", AccessType, ["|", Priority] ;
ResourceType = "resource" | "type" | "type-rec" ;
Entity       = String | "regexp(", String, ")" ;
AccessType   = "read" | "write" | "write_limited" | "write_properties";
</source>

where ''String'' is a URI or a regular expression and ''Priority'' is an integer.

There are three mechanisms to restrict access to pages, encoded by the <nowiki>ResourceType</nowiki>  specification:

* ''resource'': control page access by specifying the URI or a URI pattern
* ''type'': control access to instances of a given type
* ''type-rec'': control access to instances of a given type

Note that ''type-rec'' only differs from ''type'' if the underlying repository supports inferencing (e.g., a OWLIM triple store is initialized with a rule set implementing inferencing at type level). An example for the three mechanisms will be given in the following.

Page-level ACLs are checked prior to loading a page. When a user does not have access to a page (i.e., when the keyword in the first field equals ''deny''), then the page will not be loaded; instead, an AccessDenied page will be displayed. When the user has access rights, then the rights depend on which <nowiki>AccessType</nowiki>  is granted to the user:

* ''read'': the user is allowed to read the resource's page (and use widgets that are embedded), but he is not allowed to modify the wiki page and enter data
* ''write_properties'': the user has ''read'' access and, in addition, he is allowed to modify properties of the resource, but he is not allowed to edit the wiki page
* ''write_limited'': the user has ''read'' access and, in addition, he is allowed to edit the wiki page unless it contains widgets; in case there are no widgets, he is '''not''' allowed to add new widgets to the page.
* ''write'': the user has ''write_limited'' access and, in addition, he is allowed to edit the wiki page also in case it contains widgets; he is also allowed to add new widgets to the page.

Note that, as discussed later, it can be orthogonally specified which widgets are shown to the user (i.e., widgets of a certain type can be generally forbidden in ACLs). In this line, the page-level access control rules only grant basic read and write access rights to the page.

==== Resource-based AC Rules ====
Resource-based AC rules specify access rights to a page with a given URI (in case <nowiki><Entity></nowiki>  is a <nowiki><String></nowiki> ) or to a set of pages whose URI matches the specified regexp (in case <nowiki><Entity></nowiki>  is a <nowiki><RegexpExp></nowiki> ).

As an example, consider the following ACL.

<source>
allow|resource|http://www.fluidops.com/admin/DataExport|read
deny|resource|regexp(http:\/\/www\.fluidops\.com\/admin\/.*)
allow|resource|regexp(.*)|write_limited
</source>

First recall that the list is interpreted sequentially. Thus, it grants ''read'' access to the ''DataExport'' page in the admin namespace (which means the user can read this page and use widgets that are embedded in the page, unless they are explicitly blocked), forbids access to all other admin pages, and grants ''write_limited'' access to the pages/URIs not covered by the first two rules.

==== Type-based AC Rules ====
Type-level AC rules specify access rights for pages based on types (in case <nowiki><Entity></nowiki>  is a <nowiki><String></nowiki> ) or type patterns matched by a specified regexp (in case <nowiki><Entity></nowiki>  is a <nowiki><RegexpExp></nowiki> ).

As an example, consider the following ACL.
<source>
allow|type|foaf:Person|write
allow|type-rec|http://xmlns.com/foaf/0.1/Organization|write_limited
deny|type|regexp(http:\/\/xmlns.com\/foaf\/0\.1\/.*
allow|type|regexp(.*)|read
</source>

Assuming that the prefix ''foaf'' is defined and maps to ''<nowiki>http://xmlns.com/foaf/0.1/</nowiki>''. The rule gives full write access to direct instances of type ''foaf:Person'', ''write_limited'' access to all instances of type ''foaf:Organization'', thereby taking instances RDFS semantics into account (i.e., ''type-rec'' considers typing recursively), denies access to all other instances of classes in the foaf namespace, and grants ''read'' access to all other instances.

Note that untyped instances are not matched by the last AC rule (i.e., the specification above would not give any access to untyped instances). Further note that ''type-rec'' only has an effect if inferencing is supported by and enabled in the RDF database. Concerning the ''foaf'' prefix used in the first rule, it should be noted that prefixed URI syntax is not supported in regular expressions: there, always the full URI or pattern has to be specified.

=== Functional-level AC Rules ===
A functional-level AC Rule is a string of the form

<source>
FunctionalRule = Permission, "|", Function, "|", Entity, ["|", Priority] ;
Permission     = "deny" | "allow" ;
Function       = "widget" | "file" | "ui" | "api" | "action" | "servlet" | "query" ;
Entity         = String | "regexp(", String, ")" ;
</source>

where ''String'' is an URI or a regular expression and ''Priority'' is an integer.

Note that, compared to resource-level AC rules, functional-level AC rules are binary in the sense that they either grant or deny access (i.e., there is no fourth field specifying the level of access). Examples for the different <nowiki>Function</nowiki> s will be given in the following.

==== Widget AC Rules ====
Widget AC rules specify which widgets are displayed to the user, based on either an exact widget class specification (in case <nowiki><Entity></nowiki>  is a <nowiki><String></nowiki> ) or a regular expression (in case <nowiki><Entity></nowiki>  is a <nowiki><RegexpExp></nowiki> ). If a user does not have access to a widget, a wiki page embedding the widget will display an ''Access Denied'' message on the wiki page, instead of the widget.

As an example, consider the following ACL.

<source>
deny|widget|com.fluidops.iwb.widget.UserManagementAdministrationWidget
allow|widget|regexp(.*)
</source>

The ACL revokes access to the User Management administration widget, while all the remaining widgets are shown to the user.

==== File AC Rules ====
File AC rules specify which files (residing on the server) can be access by the user, based on either an exact file name specification (in case <nowiki><Entity></nowiki>  is a <nowiki><String></nowiki> ) or a regular expression matching the file (in case <nowiki><Entity></nowiki>  is a <nowiki><RegexpExp></nowiki> ).

File access can either be implicit by a widget (such as the ''FileEditWidget'', which allows to edit files on the server) or explicit file access (e.g. through the File Servlet). 

As an example, consider the following ACL.

<source>
allow|file|config/widgets.xml
allow|file|regexp(data\/backup\/.*)
deny|file|regexp(.*)
</source>

The ACL revokes grants access to the file ''widgets.xml'' residing in the server's config directory and all files in the backup directory, while protecting all other files. Note that, if there are no rules following, then the last (i.e., denying) rule is obsolete.

==== UI AC Rules ====
UI AC rules can be used to ban certain buttons or tabs from the User Interface, based on either the UI component ID as listed below (in case <nowiki><Entity></nowiki>  is a <nowiki><String></nowiki> ) or a regular expression matching the UI component ID (in case <nowiki><Entity></nowiki>  is a <nowiki><RegexpExp></nowiki> ). They can be used to customize the UI look and functionality, e.g. to hide the Admin button for users that do not have access to the Admin area anyway, to avoid links leading to an ''Access Forbidden'' error message.

As an example, consider the following ACL.

<source>
deny|ui|btn_admin
deny|ui|btn_revisiondelete
allow|ui|regexp(.*)
</source>

The specification hides the ''Admin'' button in the top header bar and forbids the deletion of wiki revisions, while all other restrictable UI components are displayed. A full list of UI components that can be customized through ACL lists is given in the listing below:

* ''btn_admin'': hides or displays the ''Admin'' button in the top menu bar
* ''btn_fileupload'': hides or displays the ''File Upload'' button (plus associated functionality) in the top menu bar; note that the FileUpload widget itself is not affected
* ''btn_revisiondelete'': disables or enables the button and functionality for deleting wiki page revisions
* ''btn_revisionrestore'': disables or enables the button and functionality for restoring old wiki page revisions
* ''view_stmttabledelete'': disables or enables the buttons for deleting statements in the tabular view (note that, even if enabled, only those statements that are editable can be deleted)
* ''view_tableviewedit'': disables or enables the tabular edit view

It should be noted that this functionality is closely coupled to the page-level restrictions. A user who does not have at least ''write_limited'' access to a page, for example, will therefore not see a revision delete button, even though it might be enabled explicitly.

==== API AC Rules ====
API AC rules specify API functions that can be accessed by the user via the CLI or REST endpoint, based on either an exact API function specification on the interface (in case <nowiki><Entity></nowiki>  is a <nowiki><String></nowiki> ) or a regular expression matching the API function or SubAPI (in case <nowiki><Entity></nowiki>  is a <nowiki><RegexpExp></nowiki> ).

As an example, consider the following ACL.

<source>
allow|api|com.fluidops.iwb.api.API.load
deny|api|regexp(.*)
</source>

The ACL grants access to the function for loading data via API, but revokes access to all the remaining API calls. Please note that forbidding (allowing) a certain API call or sub-API does '''not''' automatically forbid (allow) the invocation of sub-APIs or dynamic services.

Further examples

<source>
1) allow everything:   allow|api|regexp(.*)
2) allow specific method:   allow|api|com.fluidops.coremgmt.backend.BackendService.version
3) allow all methods in a service:   allow|api|regexp(com\.fluidops\.iwb\.api\.API\..*)
4) allow access to a specific sub service:   allow|api|regexp(com\.fluidops\.iwb\.api\.ProviderService\..*)
5) allow access to a dynamic service:   allow|api|regexp(dynamic\.MyDynamicServiceName\..*)
6) allow access to a method of a dynamic service:   allow|api|dynamic.MyDynamicServiceName.helloWorld
</source>

==== Action AC Rules ====
Certain widgets such as [[Help:CodeExecution|CodeExecution]] allow to call Java methods from the user interface. Action rules control the access to such methods. 

Consider the following example code:

<source>
@CallableFromWidget(authorization="infrastructure.vm.start")
public void startVm(CodeExecutionContext ceCtx, URI uri ) throws Exception
{ ... }
</source>

The Java annotation ''@CallableFromWidget'' specifies that the method ''startVm'' may only be called by users with the access right ''infrastructure.vm.start''. The following ACL grants this access right, but denies the execution of other methods from the infrastructure namespace:

<source>
allow|action|infrastructure.vm.start
deny|action|regexp(infrastructure\..*)
</source>

==== Servlet ACLs ====
Servlet AC rules specify Servlet restriction functions, based on either an exact servlet specification (in case <nowiki>Entity</nowiki>  is a <nowiki>String</nowiki> ) or a regular expression matching the servlet class name (in case <nowiki>Entity</nowiki>  is a <nowiki>RegexpExp</nowiki> ).

As an example, consider the following ACL.

<source>
deny|servlet|com.fluidops.iwb.server.FileServlet
allow|servlet|regexp(.*)
</source>

The ACL grants access to all servlets except for the FileServlet, i.e. the user is not allowed to download any files using the servlet. Please make sure to be careful when using servlet-level restrictions: some widgets may use servlets to communicate with the systems, and denying servlets to the user may break them. Forbidding servlets should thus be understand as a way to restrict certain tasks in a high-security settings.

==== Query ACLs ====
Query AC rules specify the type of queries that are allowed in the search input field, based on either a query type specification (in case <nowiki><Entity></nowiki>  is a <nowiki><String></nowiki> ) or a regular expression matching the parameters (in case <nowiki><Entity></nowiki>  is a <nowiki><RegexpExp></nowiki> ). Valid query type specifications are ''CONSTRUCT'' (covering SPARQL <i>CONSTRUCT</i> and <i>DESCRIBE</i> queries), ''ASK'' (covering SPARQL <i>ASK</i> queries), ''SELECT'' (covering SPARQL <i>SELECT</i> queries), and ''UPDATE'' (covering SPARQL <i>UPDATE</i> queries).

As an example, consider the following ACL.

<source>
deny|query|UPDATE
allow|query|regexp(.*)
</source>

The ACL grants allows the user to post all queries except for SPARQL <i>UPDATE</i> queries.

==== Request URL ACLs ====
Request URL AC rules specify what kinds of HTTP(S) requests are allowed.

As an example, consider the following ACL.

<source>
allow|requesturl|regexp(/download/.*)
</source>

The ACL grants the user access to all *.jsp files in the webapps/ROOT/download folder.

If you would like to activate ACL checks for other file types also, please add the file webapps/ROOT/WEB-INF/extensions.xml:

<source>
<filter-mapping>
	<filter-name>AclFilter</filter-name>
    <url-pattern>/download/*</url-pattern>
</filter-mapping>
</source>


=== ACL Specification ===
ACLs can be specified by ACL files. For each user role, there is a file in the directory <i>config/acl</i> with the name <i>role-''name''.acl</i>. The file associates an ACL to users in role ''name''. Note that the different ACL types described above are typically mixed in a single file. As an example, consider the following ACL file:

<source>
deny|widget|com.fluidops.iwb.ui.ProviderEditTable
deny|widget|com.fluidops.iwb.ui.WidgetEditTable
deny|widget|com.fluidops.iwb.widget.ImportRDFWidget
deny|widget|com.fluidops.iwb.widget.ExportRDFWidget
deny|widget|com.fluidops.iwb.widget.VoIDWidget
deny|widget|com.fluidops.iwb.widget.ContextEditTableWidget
deny|widget|com.fluidops.iwb.widget.BackupWidget
deny|widget|com.fluidops.iwb.widget.EditorialWidget
deny|widget|com.fluidops.iwb.widget.FileEditWidget
deny|widget|com.fluidops.iwb.widget.UserManagementAdministrationWidget
allow|widget|regexp(.*)

deny|servlet|com.fluidops.iwb.server.FileServlet
allow|servlet|regexp(.*)

deny|api|regexp(.*)

deny|file|regexp(.*)

deny|ui|btn_admin
deny|ui|btn_revisiondelete
allow|ui|regexp(.*)

allow|resource|regexp(http:\/\/www\.fluidops\.com\/admin\/.*)
allow|resource|regexp(.*)|write
</source>

The first block in the specification are functional-level widget restriction, forbidding access to a variety of administration widgets and granting access to all the widgets that are not explicitly excluded. Next, all servlets are enabled except for the FileUpload servlet. Further, access to the API and server file access is completely denied, and the admin and revision delete buttons are hidden in the ''ui'' ACL rules. Finally, all pages are enabled except for the pages in the admin area.

=== Role Composition & Metadata ===
ACLs can include other ACLs, which allows for a logical composition of roles. For example, the ACL role ''guest'' includes the roles ''platform-base'', ''wiki-view'', and ''file-user'':

<source>
@includeRole: platform-base
@includeRole: wiki-view
@includeRole: file-user
</source>

These includes allow guest users to view widgets, to access wiki pages, and to download files.

Roles can also declare to be included by other roles. This allows apps to extend existing roles without touching the original ACL files. For example, the ACL ''extended-user'' might extend the regular role ''user'' (meaning that each member of the role ''user'' additionally receives the permissions given by ''extended-user''):

<source>
@includedByRole: user
</source>

See [[Help:PlatformRoles| here]] for a list of available roles.

In addition it is possible to provide metadata like the display name and a description in form of annotations:

<source>
@displayName: My Nice Role
@descriptiom: This is the description of my new role
</source>

These annotations are used in the [[Admin:Permissions|ACL UIs]] for displaying role information.
