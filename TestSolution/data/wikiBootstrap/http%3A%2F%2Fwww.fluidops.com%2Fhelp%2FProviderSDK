== Provider SDK ==

This section describes how data providers for custom data-sources can be written and deployed into the {{PRODUCT}}. Generally, there are two ways for doing this: 

# Leveraging groovy scripts in a [[Help:ScriptProvider| script provider]] 
# writing a custom provider implementation following the guide below.

For details and the documentation of the script provider as well as the mapping framework please refer to respective [[Help:ScriptProvider| documentation]].

In the following we present how a custom provider can be implemented and registered.


=== Implementing the Provider ===

Providers in the {{PRODUCT}} extend the ''com.fluidops.iwb.provider.AbstractFlexProvider<nowiki><T></nowiki>''.

A provider implementation consists of two essential parts:

* the provider configuration
* the ''gather'' implementation, which produces the statements

The provider configuration is a ''Serializable'' Java POJO with the configuration settings declared as public fields. Additional meta information (such as a description and component used in the [[Help:Providers| provider configuration form]]) can be provided using the ''@ParameterConfigDoc'' annotation. Consider the following snippet from the [[Help:SPARQLEndpointProvider| SPARQL endpoint provider]] for illustration:

<source>
public static class Config implements Serializable {
  
   private static final long serialVersionUID = 1L;

   @ParameterConfigDoc(
	desc = "URL of the SPARQL endpoint",
	required = true)
   public String endpoint;
		
   @ParameterConfigDoc(
        desc = "The CONSTRUCT query that is executed against the given endpoint.",
	type = Type.SPARQLEDITOR,
	required = true)
   public String query;
		
   @ParameterConfigDoc(
	desc = "The (optional) user credentials used for basic authentication at the given SPARQL endpoint.")
   public User user;

}
</source>

Once the configuration is defined, the ''gather'' method can be implemented. The implementation fills the provided list with the statements extracted from the respective source. The provider framework takes care for persisting all triples in the underlying database.

For creating ''Statements'' or ''ontology objects'', and more particularly ''URIs'' and ''Literals'', the platform offers a set of [[Help:DataManagementApi| convenience functionality]], which we recommend to use when not directly working on an RDF data source.

Best practices for implementing a provider

* Create data in a designated [[Help:NamespaceConfig| namespace]]
* Make use of ontologies and if possible reuse existing ones
* Avoid using fields in the provider implementation class, if required declare them transient to avoid serialization
* Make sure that resources (streams, connections, ...) are closed, and use appropriate timeouts
* Do not write statements to the triple store directly, but use the provider mechanism
* Throw errors encapsulated in meaningful exception



Please refer to the example below or to the implementation of the shipped data providers for an illustration.

=== Registering Custom Providers ===

In a [[Help:SDK-SystemConfiguration| solution artifact]] the file <code>config/providers.prop</code> lists those providers that can be configured using the UI. The classes are registered with the application's provider service.

Before providers can be used in the {{PRODUCT}}, they need to be registered as illustrated in the following example (one provider per line):

<source>
com.fluidops.iwb.provider.MyCustomProvider=true
</source>


=== Example ===
The toy example below illustrates a provider that extracts meta information about files, given a server directory in its configuration as input.

<source>
/**
 * A demo provider for illustration which uses the RDF utilities 
 * and Sesame API to gather new statements.
 * 
 */
public class DemoProvider extends AbstractFlexProvider<DemoProvider.Config>{

	private static final long serialVersionUID = 1L;

	public static class Config implements Serializable {

		private static final long serialVersionUID = 1L;
		
		@ParameterConfigDoc(desc="The identifier of the object", required=true)		
		public URI objectIdentifier;
		
		@ParameterConfigDoc(desc="The type of the Object", required=true)
		public URI objectType;
		
		@ParameterConfigDoc(desc="An endpoint providing additional RDF data for the object")
		public String additionalDataEndpoint;
	}
	

	@Override
	public void gather(final List<Statement> res) throws Exception {

		Config c = config;
		
		// use the RDFUtils to create the object and generate statements
		OWLObject object = RDFUtil.newObject(c.objectIdentifier, c.objectType);
		object.addValue(RDFS.COMMENT, RDFUtil.literal("My demo object"));
		res.addAll( object.asStatements() );
		
		// retrieve additional information from the endpoint
		// Assumption: endpoint produces RDF/XML data
		URL url = new URL(config.additionalDataEndpoint);
		URLConnection conn = url.openConnection();
		RDFLoader loader = new RDFLoader(new ParserConfig(), ValueFactoryImpl.getInstance());
		loader.load(conn.getInputStream(), url.toString(), RDFFormat.RDFXML, new RDFHandlerBase() {
					@Override
					public void handleStatement(Statement st) throws RDFHandlerException {
						res.add(st);
					}
				});		
	}
	
	@Override
	public Class<? extends Config> getConfigClass() {
		return Config.class;
	}
}
</source>


== Persisting credentials & secret keys securely ==

Often [[Help:Providers| providers]], [[Help:DataSources| data sources]] and [[Help:Tasks| tasks]] require credentials or a secret key (e.g. credentials that are used for authenticating at a service). Naturally this information should not be persisted in plain text, but in a secure storage. For this {{PRODUCT}} uses a ''secrets'' database (persisted in ''secrets.xml'' in the installation directory) which keeps the credential records in an encrypted fashion.

In the following the framework for this is described in more detail.

=== User credentials ===

For specifying user credentials in a provider configuration the special ''User'' class can be used: whenever a provider configuration is changed and saved, the password is ''masked'' and the actual password is persisted in a secure storage. The same mechanism can be applied to [[Help:DataSources| data sources]] and [[Help:Tasks| tasks]].

<source>
public static class Config implements Serializable {
		
   @ParameterConfigDoc(desc = "The user credentials.")
   public User user;
}
</source>

To retrieve the actual password value from the secure storage (e.g. from within the ''gather'' implementation, the following code snippet can be used, where ''this'' is pointing to the current provider instance.

<source>
config.user.password(this)
</source>

Note that such ''User'' object can be defined on different levels in the configuration hierarchy, e.g. also in sub configurations. A current limitation is that the ''username'' is used as a key per provider, meaning that the same username cannot be used with different passwords in the same provider configuration.

=== Secret keys ===

Since 8.0 {{PRODUCT}} supports to persist secret keys into a secure store (e.g. a password which is not associated to a concrete user). For this the annotation needs to define that the respective field should be treated as a password. At load / save time the password is retrieved / stored in the secure storage. See below snippet for illustration.

Note that this mechanism is currently only supported for data providers.

<source>
public static class ConfigDemo
{
	@ParameterConfigDoc(desc = "The secret key", type = Type.PASSWORD)
	public String key;
}
</source>

There can be multiple such password definitions in a configuration (also in sub configuration), however, the fields must have distinct names. In contrast to the ''User'' mechanism described above, the respective password field can be directly accessed, i.e. it is not required to use a mechanism like the ''password()'' accessor to retrieve the plain text password.